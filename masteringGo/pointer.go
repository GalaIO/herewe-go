package main

import (
	"fmt"
)

func main() {
	// go语言同样支持指针，指针就是指向内存地址的变量，根据指针的类型，编译器可以识别如何对内存进行操作
	// 比如切片，或者结构体等等
	// 对于使用指针的场景，1.交出使用权，使用指针对数据的修改会影响内存，而对于传值的修改只影响实参；
	// 2.引用堆内存，对于对上内存由于大小可变，只能指针指向地址，无法分配到栈上

	var s string = "1234"
	// 指针定义就是在类型前加*，表示指针类型，对于获取值的指针 使用&开头即可，&即取地址操作符
	var p *string = &s

	// 使用*p表示 指针的解引用，指向实际值
	*p = "2345"
	fmt.Println(s, *p, p)

	// 指针的值可以随意修改，但是非常不推荐这么做，比如随便搞了一个地址上去，直接panic
	// panic: runtime error: invalid memory address or nil pointer dereference
	// 使用go的指针 只建议 *p 去使用，修改值，不建议操作指针
	//p = (*string)(unsafe.Pointer(uintptr(1)))
	//fmt.Println(s, *p)

	// 指针在函数或者方法使用时传递，让函数逻辑修改原值
	concat := func (p *string, s string) {
		*p = *p + s
	}
	concat(p, "4321")
	fmt.Println(s, *p, p)

	// 对于指针来说go有一个特殊点，看下面函数
	// go允许把栈变量变成指针返回 继续使用操作内存。。。
	getPointer := func() *int {
		tmp := 1
		return &tmp
	}
	p2 := getPointer()
	fmt.Println(*p2, p2)

	// 这里面说要go的内存逃逸分析，对于程序而言最好的操作是所有的变量都申请在栈上
	// 由于栈内存是确定的，所以无需垃圾回收，在退出函数时销毁栈即可，而且顺序内存非常利于cpu多级缓存
	// 对于go来说，默认的栈行为 比如局部变量、数组等都会在栈分配，同时逃逸分析会把只会在当前作用域使用的变量也会分配在栈，
	// 哪怕是new、make出来的切片、映射、结构体等等，极大降低垃圾回收的压力，尤其是碎片化的小内存申请
	// 具体哪些发生逃逸，可以使用命令分析 go build -gcflags '-m -m -l' main.go
	// 对于不逃逸的都是在栈分配，这些都是在编译器决定的
	// 更多参考 https://www.do1618.com/archives/1328/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/

	// 参考规则：
	// 1.slice 由于 append 操作超出其容量，因此会导致 slice 重新分配。这种情况下，由于在编译时 slice 的初始大小的已知情况下，将会在栈上分配。如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上。
	// 如果 slice 大小超过 64k，则会分配到堆上 （go 1.9.2)
	// 2.转换为interface都会逃逸到堆上，go 中的接口类型的方法调用是动态调度，因此不能够在编译阶段确定，所有类型结构转换成接口的过程会涉及到内存逃逸的情况发生。
	// 3.slices 中的值是指针的指针或包含指针字段。一个例子是类似[] *string 的类型。这总是导致 slice 的逃逸。即使切片的底层存储数组仍可能位于堆栈上，数据的引用也会转移到堆中。
	// 4.发送指针的指针或值包含了指针到 channel 中，由于在编译阶段无法确定其作用域与传递的路径，所以一般都会逃逸到堆上分配。
	// 5.尽管能够符合分配到栈的场景，但是其大小不能够在在编译时候确定的情况，也会分配到堆上
}
